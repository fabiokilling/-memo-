正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对
字符串的一种过滤逻辑。

非Python独有，re模块实现

正则 
^表示行的开头，^\d表示必须以数字开头。
$表示行的结束，\d$表示必须以数字结束。
你可能注意到了，py也可以匹配'python'，但是加上^py$就变成了整行匹配，就只能匹配'py'了。
.可以匹配任意字符，所以：
'py.'可以匹配'pyc'、'pyo'、'py!'等等。
用\d可以匹配一个数字，\w可以匹配一个字母或数字
\s匹配空格
来看一个复杂的例子：\d{3}\s+\d{3,8}。
我们来从左到右解读一下：
\d{3}表示匹配3个数字，例如'010'；
\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
\d{3,8}表示3-8个数字，例如'1234567'。
综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。
如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\'转义，所以，上面的正则是\d{3}\-\d{3,8}。
但是，仍然无法匹配'010 - 12345'，因为带有空格。所以我们需要更复杂的匹配方式。



match函数
用来检测正则表达式
re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
re.match(pattern,string,flags=0)

result.group()    返回匹配结果
result.span()     输出匹配结果的范围


匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了
\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编 的规则是5位数字，或者用连字号间隔的9位数字。
之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。
如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。

^.*$  #这里^代表开头，$代表结尾，然后.代表匹配除换行符以外的任意字符，*代表重复零次或更多次
而\b	匹配单词的开始或结束，用法为
例如\ba\w*\b匹配以字母a开头的单词——-----先是某个单词开始处(\b)，
然后是字 母a,然后是任意数量的字母或数字(\w*)， 最后是单词结束处(\b)。
\w	匹配字母或数字或下划线或汉字
\s	匹配任意的空白符


(?<=<(\w+)>).*(?=<\/\1>)
(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。
(<?(\w+)>)指定了这样的前缀：
被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。
注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹 配的内容，
这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b> 之间的内容(再次提醒，不包括前缀和后缀本身)。
      (?<=    # 断言要匹配的文本的前缀
      <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )       # 前缀结束
      .*      # 匹配任意文本
      (?=     # 断言要匹配的文本的后缀
      <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )       # 后缀结束

re.match('^He.*?(\d+).*?Demo$')

import re
content = '''Hello 1234567 World_This
is a Regex Demo
'''
result =re.match('^He.*?(\d+).*?Demo$',content,re.S)

总结：尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.S(不使用的话没法匹配换行符)
